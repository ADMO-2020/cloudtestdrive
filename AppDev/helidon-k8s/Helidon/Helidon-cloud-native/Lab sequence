
Cloud Native capabilities section
=================================
These show how you can use Helidon to directly support the cloud native capabilities that Kubernetes uses. It does not directly
cover using them in Kubernetes however, but if you're doing the microservices in kubernetes sections of the workshop then this
will make sense when you do it.

Health
======
System has built in health info
By default they are on the same port as the service, but just for run config (conf/storefront-config.yaml) separates these 
onto different ports (8080 for the service, 9080 for the non service)
Look at http://localhost:9080/health to see the details
See it has default info like CPU and so on

Liveness
========
Services like kubenetes can check to see if the microservice is alive (e.g. not in deadlock) the liveness service, if there is no liveness
then kubenetes can restart it.
Add the @Liveness to the storefront.health.LivenessChecker
Restart the services
Look at http://localhost:9080/health
Note that now there is a storefront-live entry.
Going to Look at http://localhost:9080/health/live shpould limit to just the liveness data, but for some reason it doesn't
Ignore the stuff about /frozen in the call method, this is something we'll use in the lubernetes labs do demonstrate what happens if 

Readiness
=========
Readiness is a way to let the microservices runtime determine if a service has everything it needs to respond to requests, this may be because 
of a temporary condition that will recover, so don't want to restart the whole service
add @Readiness to ReadinessChecker
Look at ReadinessChecker, note that it uses a RestClient to see if the backend service is available.
Restart and look at http://localhost:9080/health/ready
